# -*- coding: utf-8 -*-
"""sih-CV.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YIQFLX7X15D3kW99MOPQgzgajxsnu2GB
"""

!pip install selenium
!apt-get update # to update ubuntu to correctly run apt install
!apt install chromium-chromedriver
!cp /usr/lib/chromium-browser/chromedriver /usr/bin

# downloading blob images
!mkdir -p /content/images
!wget https://github.com/DumbMachine/_frontend-AI/raw/master/image/data/blob0.png
!wget https://github.com/DumbMachine/_frontend-AI/raw/master/image/data/blob1.png
!wget https://github.com/DumbMachine/_frontend-AI/raw/master/image/data/blob2.png

import sys
import cv2
import time
import pandas as pd 
import folium
import uuid
import matplotlib.pyplot as plt
sys.path.insert(0,'/usr/lib/chromium-browser/chromedriver')
from selenium import webdriver

def location_pic(location, driver=None, zoom=20, tiles=None):
    filename = str(uuid.uuid4())
    if driver is None:
        chrome_options = webdriver.ChromeOptions()
        chrome_options.add_argument('--headless')
        chrome_options.add_argument('--no-sandbox')
        chrome_options.add_argument('--disable-dev-shm-usage')
        driver = webdriver.Chrome('chromedriver',chrome_options=chrome_options)

    if tiles is None:
        world_map = folium.Map(
            location=location, zoom_start=zoom
            )
    else:
        world_map = folium.Map(location=location,  zoom_start=zoom, tiles=tiles)
    world_map.save("temp.html")
    driver .get("file:///content/temp.html")
    time.sleep(3)
    driver.save_screenshot(f'images/{filename}.png')
    return f'images/{filename}.png'

#@title Creating Some Circles { run: "auto" }
N = 30
TILE = 'Stamen Terrain'
DEGREE = 90
line_grid = []
all_points = []
line = []
all_points = []

line1_lat, line1_lon = (2, 74) #@param {type:"raw"}
line2_lat, line2_lon = (10, 73) #@param {type:"raw"}
line_width = 10 #@param {type:"raw"}

lat1, lon1 = (13.171054833622044, 75.87038261100483) #@param {type:"raw"}
radius1, trust1 = (5.251052195950642, 75)  #@param {type:"raw"}
# -------------
lat2, lon2 = (15.337583, 75.420917) #@param {type:"raw"}
radius2, trust2 = (10.530432089900206, 57)  #@param {type:"raw"}

m = folium.Map(zoom_start=5, location=circles[0]["center"],  tiles=TILE)

if lat1 !=0 and lon1 !=0 and lat2 !=0 and  lon2 !=0 and line_width!=0:
    (lat1, lon1), (lat2, lon2), width = (line1_lat, line1_lon), (line2_lat, line2_lon), line_width
    folium.PolyLine([(lat1, lon1), (lat2, lon2)]).add_to(m)
    strip = [0.52, 0.223, 0.017][::-1]
    for i in range(1, 4)[::-1]:
        DEGREE = 90
        rectangle = [
            displace(lat1, lon1, DEGREE, width*i)[::-1],
            displace(lat1, lon1, -DEGREE, width*i)[::-1],
            displace(lat2, lon2, -DEGREE, width*i)[::-1],
            displace(lat2, lon2, DEGREE, width*i)[::-1]
        ]
        rectangle+= [rectangle[0]]
        coordinates = rectangle
        geo_json = {"type": "FeatureCollection",
                    "properties": {
                        "lower_left": rectangle[0],
                        "upper_right": rectangle[2]
                    },
                    "features": []}

        grid_feature = {
            "type": "Feature",
            "geometry": {
                "type": "Polygon",
                "coordinates": [coordinates],
            }
        }
        geo_json["features"].append(grid_feature)
        geo_json["prob"] = strip[3-i]
        color = plt.cm.Greens(geo_json["prob"])
        color = mpl.colors.to_hex(color)
        geo_json["color"] = color
        line_grid.append(geo_json)
        all_points.extend([rec[::-1] for rec in rectangle])
    #     folium.PolyLine([rec[::-1] for rec in rectangle]).add_to(m)


circles = [{"center": [lat1, lon1],
        "radius": radius1,
        "strip": [0.5,0.2,0.1],
        "trust": trust1},
        {"center": [lat2, lon2],
        "radius":  radius2,
        "strip": [0.5,0.2,0.1],
        "trust": trust2}]

if circles:
    for circle in circles:
        circle["rad_strips"] = []
        points, points1, points2 = [], [], []

        x, y = circle["center"]

        points.extend(PointsInCircum(x, y, circle['radius']*1*0.02, n=100)) #6,092 km
        circle["rad_strips"].append(distance_(points[0], circle["center"]))
        points1.extend(PointsInCircum(x, y, circle['radius']*2*0.02, n=100))
        circle["rad_strips"].append(distance_(points1[0], circle["center"]))
        points2.extend(PointsInCircum(x, y, circle['radius']*3*0.02, n=100))
        circle["rad_strips"].append(distance_(points2[0], circle["center"]))

        all_points.extend(points)
        all_points.extend(points1)
        all_points.extend(points2)

        folium.PolyLine(points, color="green", popup="first").add_to(m)
        folium.PolyLine(points1, color="red", popup="second").add_to(m)
        folium.PolyLine(points2, color="blue", popup="third").add_to(m)

if all_points:   
    xx, yy = zip(*all_points)
    min_x = min(xx)
    min_y = min(yy)
    max_x = max(xx)
    max_y = max(yy)
    bbox = [(min_x, min_y), (max_x, min_y), (max_x, max_y), (min_x, max_y)]
    bbox += [bbox[0]]

    lower_left, upper_right = bbox[0], bbox[2]
    grid = get_geojson_grid(upper_right, lower_left, n=N)
    new_grid = all_grid(grid, circles)
    new_grid += line_grid
    folium.PolyLine(bbox).add_to(m)

m

line1_lat, line1_lon

for i, geo_json in enumerate(new_grid):
    gj = folium.GeoJson(geo_json,
                        style_function=lambda feature: {
                            'fillColor': color,
                            'fillOpacity':0.2,
                        })
    popup = folium.Tooltip(f"confidence={geo_json['prob']}")
    gj.add_child(popup)
    popup = folium.Popup(i//len(new_grid))
    gj.add_child(popup)

    m.add_child(gj)

#@title Display Grid Member
temp_grid = [new_grid[i:i+N] for i in range(N)]
i =  29#@param {type:"integer"}
j =  29#@param {type:"integer"}
zoom = 12
tiles = "Stamen Terrain" #@param ["None", "Stamen Toner", "Stamen Terrain", "Mapbox Bright"]
tiles = None if tiles is "None" else tiles
if i > len(new_grid) or j > len(new_grid):
    print("Wrong INput")
else:
    geo_json = temp_grid[i][j]
    _points = geo_json["features"][0]["geometry"]["coordinates"][0][:-1]

    image = plt.imread(location_pic(_points[0][::-1], zoom=zoom, tiles=tiles))
    plt.imshow(cv2.resize(image, (1020, 400)))
    print(image.shape)

#@title Display Grid Member with Fake Smoke
smoke_blob_id = "blob2.png" #@param ["blob0.png", "blob1.png", "blob2.png", "blob3.png", "blob4.png"]
base = image[:,:,:3]
masks = [
    cv2.resize(cv2.imread(f"/content/{smoke_blob_id}"), base.shape[:2][::-1])
]
mask = random.choice(masks)
dst = cv2.addWeighted(mask, 0.2, base, 1.0, 0,  dtype = cv2.CV_32F)
im1 = Image.fromarray(base.astype(np.uint8))
im2 = Image.fromarray(dst.astype(np.uint8))
diff = ImageChops.difference(im2, im1)
cols, rows = autocrop(np.array(diff))
last = cv2.rectangle(dst.copy(), (rows[0] , cols[0]), (rows[-1] + 1, cols[-1] + 1), (0, 255, 0), 2)
array = np.array([base, mask, dst, last])
result = gallery(array, ncols=len(array))
plt.imshow(cv2.resize(result, (1020, 400)))



def gallery(array, ncols=3):
    nindex, height, width, intensity = array.shape
    nrows = nindex//ncols
    assert nindex == nrows*ncols
    # want result.shape = (height*nrows, width*ncols, intensity)
    result = (array.reshape(nrows, ncols, height, width, intensity)
              .swapaxes(1,2)
              .reshape(height*nrows, width*ncols, intensity))
    return result

import cv2
import numpy as np
import matplotlib.pyplot as plt

from PIL import Image, ImageChops

def autocrop(image, threshold=0):
    """Crops any edges below or equal to threshold

    Crops blank image to 1x1.

    Returns cropped image.

    """
    if len(image.shape) == 3:
        flatImage = np.max(image, 2)
    else:
        flatImage = image
    assert len(flatImage.shape) == 2

    rows = np.where(np.max(flatImage, 0) > threshold)[0]
    if rows.size:
        cols = np.where(np.max(flatImage, 1) > threshold)[0]
        return cols, rows
    else:
        return None, None



def image_change(image, old_image):
    im1 = Image.fromarray(image)
    im2 = Image.fromarray(old_image)
    diff = ImageChops.difference(im2, im1)
    
    cols, rows = autocrop(np.array(diff))
    
    return cv2.rectangle(image.copy(), (rows[0] , cols[0]), (rows[-1] + 1, cols[-1] + 1), (0, 255, 0), 2)

import math
import folium
import random
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt

pi = math.pi
MOD = 0.0015

def get_geojson_grid(upper_right, lower_left, n=6):
    """Returns a grid of geojson rectangles, and computes the exposure in each section of the grid based on the vessel data.

    Parameters
    ----------
    upper_right: array_like
        The upper right hand corner of "grid of grids"s.

    lower_left: array_like
        The lower left hand corner of "grid of grids" s.

    n: integer
        The number of rows/columns in the (n,n) grid.

    Returns
    -------

    list
        List of "geojson style" dictionary objects   
    """

    all_boxes = []

    lat_steps = np.linspace(lower_left[0], upper_right[0], n+1)
    lon_steps = np.linspace(lower_left[1], upper_right[1], n+1)

    lat_stride = lat_steps[1] - lat_steps[0]
    lon_stride = lon_steps[1] - lon_steps[0]

    for lat in lat_steps[:-1]:
        for lon in lon_steps[:-1]:
            # Define dimensions of box in grid
            upper_left = [lon, lat + lat_stride]
            upper_right = [lon + lon_stride, lat + lat_stride]
            lower_right = [lon + lon_stride, lat]
            lower_left = [lon, lat]

            # Define json coordinates for polygon
            coordinates = [
                upper_left,
                upper_right,
                lower_right,
                lower_left,
                upper_left
            ]

            geo_json = {"type": "FeatureCollection",
                        "properties": {
                            "lower_left": lower_left[::-1],
                            "upper_right": upper_right[::-1]
                        },
                        "features": []}

            grid_feature = {
                "type": "Feature",
                "geometry": {
                    "type": "Polygon",
                    "coordinates": [coordinates],
                }
            }

            geo_json["features"].append(grid_feature)

            all_boxes.append(geo_json)

    return all_boxes


def PointsInCircum(_x, y, r, n=100):
    ret = []
    for x in range(0, n+1):
        ret.append((
                _x+float(math.cos(2*pi/n*x)*r),
                y+float(math.sin(2*pi/n*x)*r)
            ))
    return ret


def all_grid(grid, centers):
    """
    Assign prob to all the grid
    """
    for _grid in grid:
        _grid["prob"] = assign_prob(_grid, centers)
        color = plt.cm.Greens(_grid["prob"])
        color = mpl.colors.to_hex(color)
        _grid["color"] = color
    return grid


def assign_prob(geo_json, centers):
    _points = geo_json["features"][0]["geometry"]["coordinates"][0][:-1]
    xx, yy = zip(*_points)
    centroid = (sum(xx) / len(_points), sum(yy) / len(_points))[::-1]
    prob = 0
    for center in centers:
        distance = distance_(centroid, center["center"])
        radius = center["rad_strips"]
        if distance <= radius[0]:
            prob+=0.5*center["trust"]
        elif distance >= radius[0] and distance <= radius[1]:
            prob+=0.3*center["trust"]
        elif distance >= radius[1] and distance <= radius[2]:
            prob+=0.17*center["trust"]
        else:
            prob+=0*center["trust"]

    return prob


def check_range_circle(distance, radius):
    """
    Check in which range of the radius does the distance lie in
    """
    if distance < radius:
        prob = 0
    elif distance > radius and distance < 2*radius:
        prob = 1
    elif distance > 2 * radius and distance < 3*radius:
        prob = 2
    else:
        prob = -1
    return prob

import math
import numpy as np

def distance_(origin, destination):
    """
    Calculate the Haversine distance.

    Parameters
    ----------
    origin : tuple of float
        (lat, long)
    destination : tuple of float
        (lat, long)

    Returns
    -------
    distance_in_km : float

    Examples
    --------
    >>> origin = (48.1372, 11.5756)  # Munich
    >>> destination = (52.5186, 13.4083)  # Berlin
    >>> round(distance(origin, destination), 1)
    504.2
    """
    lat1, lon1 = origin
    lat2, lon2 = destination
    radius = 6371  # km

    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    a = (
            math.sin(dlat / 2) **2  +
            math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *
            math.sin(dlon / 2) **2 
         )
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    d = radius * c

    return d


def displace(lat, lng, theta, distance):
    """
    Displace a LatLng theta degrees counterclockwise and some
    meters in that direction.
    Notes:
        http://www.movable-type.co.uk/scripts/latlong.html
        0 DEGREES IS THE VERTICAL Y AXIS! IMPORTANT!
    Args:
        theta:    A number in degrees.
        distance: A number in meters.
    Returns:
        A new LatLng.
    """
    theta = np.float32(theta)

    delta = np.divide(np.float32(distance), np.float32(6471))

    def to_radians(theta):
        return np.divide(np.dot(theta, np.pi), np.float32(180.0))

    def to_degrees(theta):
        return np.divide(np.dot(theta, np.float32(180.0)), np.pi)

    theta = to_radians(theta)
    lat1 = to_radians(lat)
    lng1 = to_radians(lng)

    lat2 = np.arcsin( np.sin(lat1) * np.cos(delta) +
                        np.cos(lat1) * np.sin(delta) * np.cos(theta) )

    lng2 = lng1 + np.arctan2( np.sin(theta) * np.sin(delta) * np.cos(lat1),
                                np.cos(delta) - np.sin(lat1) * np.sin(lat2))

    lng2 = (lng2 + 3 * np.pi) % (2 * np.pi) - np.pi

    return to_degrees(lat2), to_degrees(lng2)
 
def angle_between_vectors_degrees(u, v):
    """Return the angle between two vectors in any dimension space,
    in degrees."""
    return np.degrees(
        math.acos(np.dot(u, v) / (np.linalg.norm(u) * np.linalg.norm(v))))